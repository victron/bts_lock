#!/bin/bash
# ***************** Description ************
# bts_lock1.sh
# For shutdown and un-shutdown Mu, and Se interfaces on cisco, on request
#
# 
# v.1.4.10
# get BTS site name from $1
# 

####### TO-DO ######
# - quick help
# - ping check at the end
# + aps check and exit if protect
# + aps check and start to work on router+1 if protect
# + date and time  on start
# - logging 
# ? shadow work, output in logs
# ? security (hide key password)
# ? replace file functions on array
# + wait indicator
# + rewrite  check_exit_status function and implement
# + delete files
# - Piping Grep to Awk
# + check BTS list
####### history ########
# v.1.0		- only one parameter <BTS_Name>. ASR <hostname> received from .db files.
#		.db files generated by bts_inventory.sh
# v.1.1		- pipeline added
#		while read data; do
#		echo "data = $data"
#		done
# v.1.2.1	- get <BTS_Name> from parameter, if empty get from pipeline
#
# v.1.2.2 	aps protected changed on Inactive
# v.1.3.0	separate connection for 'no shutdown' serial and multilink interfaces with delay 5 sec.
# v.1.3.1	exit from script if there are BTS in .db files !!! currently not working
# v.1.4.3	ping actions at the end
#**************************************************
#    constants block
#**************************************************
# declare -i waite_time
  waite_time=200

# file for commands
# 
# tmp files declare in next template
# <program_name>.process_number.<file_memplate  (bts_lock.sh.26051.commands.tmp)

 command_list_file="./$(basename $0).$$.commands.tmp"
 send_command_output_file="./$(basename $0).$$.output.tmp"
 command_list_shut_file="./$(basename $0).$$.commands_shut.tmp"
 aps_output="./$(basename $0).$$.aps_check_output.tmp"
 Mu_ppp="./$(basename $0).$$Mu_ppp.tmp"

#**************************************************
#    variables block
#**************************************************
  #**************************************************
  #    variables for functions
  #**************************************************

#  generate_command_list_check_2=$1
  BTS_Name_glob=""
  
#**************************************************
#    functions block
#**************************************************

  
delete_tmp_files ()
  {
  echo " start delete tmp files"
    rm $command_list_file && echo "deleted.. $command_list_file"
    rm $send_command_output_file && echo "deleted.. $send_command_output_file"
    rm $command_list_shut_file && echo "deleted.. $command_list_shut_file"
    rm $aps_output && echo "deleted.. $aps_output"
    rm $Mu_ppp && echo "deleted.. $Mu_ppp"
    return 0
  }
  
send_command ()
# send commands to server via ssh
# $2 - <comands_file>
# $1 - <server_hostname>
  {
    echo " connecting to....$1"
    cat  $2 | ssh -T $1
    #( cat commands ; sleep 100 ) | ssh -T test@bsns-asr1002-1.cisco.com
  }
  
check_exit_status ()
# check exit status code
# $1 info message if exit notOk
  {
  
    RETVAL=$?
      if [ $RETVAL -eq 0 ] ; then
#debug	echo "If=ok start exit_status"
	return 0
	  else
#debug	    echo "If=Nok start exit_status"
#debug	    echo "error=$RETVAL ----> exit"
	    delete_tmp_files
	    echo "$1 exit..$RETVAL"
	    exit $RETVAL
      fi
   }
   
   
generate_command_list_check ()
# generates commands file list $command_list_file
# $1 - <hostname>
  {
    #echo $2  >  $command_list_file
    echo "sh int desc | i $1" >  $command_list_file 
    
  }
  
check_exist_bts ()
# checking on exist bts on router
  {
    ( grep Mu $send_command_output_file || ( RETVAL=$?; echo "check list generation error... $RETVAL ";exit $RETVAL) || exit $RETVAL ) || exit $RETVAL
   }
   
generate_command_list_shut_noShut ()
# generates commands file list $command_list_shut_file
# parameter $1 shut or noshut
  {
#takes file in format 
#----------------------
#
#KIE-PRI-TVK_BSSA1#sh int desc | i KIECHNOZR345
#Se0/4/0.1/2/2/2:0              down           down     KIECHNOZR345C1
#Se0/4/0.1/2/2/3:0              down           down     KIECHNOZR345C2
#Mu18                           down           down     L3 link to KIECHNOZR345
#Se0/4/0.1/2/x2/2:0              down           down     KIECHNOZR345C1
#Se0/4/0.1/2/x2/3:0              down           down     KIECHNOZR345C2
#Mu1                           down           down     L3 link to KIECHNOZR345
#----------------------
#prepare for shutdown on cisco in format ($1=shut)
#----------------------
#conf t
#int multil1
#shut
#int multil18
#shut
#int Se0/4/0.1/2/2/2:0
#shut
#int Se0/4/0.1/2/2/3:0
#shut
#int Se0/4/0.1/2/x2/2:0
#shut
#int Se0/4/0.1/2/x2/3:0
#shut
#----------------------

  
  case "$1" in 
      "shut" )
      echo "conf t" > $command_list_shut_file
      grep -e Se -e Mu $send_command_output_file | awk '{print $1}'| sort | awk '{ gsub(/Mu/,"multil"); print "int "$1"\nshut" }' >> $command_list_shut_file
      ;;
      "shut_ser" )
      echo "conf t" > $command_list_shut_file
      grep Se $send_command_output_file | awk '{print $1}' | awk '{ print "int "$1"\nshut" }' >> $command_list_shut_file
      ;;
      "shut_mu" )
      echo "conf t" > $command_list_shut_file
      grep  Mu $send_command_output_file | awk '{print $1}'| awk '{ gsub(/Mu/,"multil"); print "int "$1"\nshut" }' >> $command_list_shut_file
      ;;
      "noshut" )
# generate conmmands for 'no shutdown' in $command_list_shut_file
      echo "conf t" > $command_list_shut_file
      grep -e Se -e Mu $send_command_output_file | awk '{print $1}'| sort -r | awk '{ gsub(/Mu/,"multil"); print "int "$1"\nno shut" }' >> $command_list_shut_file
# 'show interface des | i <BTS_Name>' at the end of 'no shutdown' 
      echo "do sh int desc | i $BTS_Name_glob" >> $command_list_shut_file
      ;;
      "noshut_ser" )
# generate conmmands for 'no shutdown' in $command_list_shut_file, only for serial links
      echo "conf t" > $command_list_shut_file
      grep -e Se $send_command_output_file | awk '{print $1}' | awk '{ print "int "$1"\nno shut" }' >> $command_list_shut_file
# 'show interface des | i <BTS_Name>' at the end of 'no shutdown' 
      echo "do sh int desc | i $BTS_Name_glob" >> $command_list_shut_file
      ;;
      "noshut_mu" )
# generate conmmands for 'no shutdown' in $command_list_shut_file, only for multilinks links
      echo "conf t" > $command_list_shut_file
      grep -e Mu $send_command_output_file | awk '{print $1}' | awk '{ gsub(/Mu/,"multil"); print "int "$1"\nno shut" }' >> $command_list_shut_file
# 'show interface des | i <BTS_Name>' at the end of 'no shutdown' 
      echo "do sh int desc | i $BTS_Name_glob" >> $command_list_shut_file
      ;;
    esac  
  }
  
generate_command_list_check_active_aps ()
# check for active APS on router
# $2 = <sh int desc | i <BTS>_file> output_file, 
# $2 = <APS_output>, if $1 ="analyze_resp  
# $3 = file in format:
# ------------------
# show aps controller sonET 0/3/1
# show aps controller sonET 0/3/1
# ==================
# $1 = "request_list" or "analyze_resp" (generate list for APS state request or analyze response  )

  {
  case "$1" in
    "request_list" )
      grep -e Se $2 | awk '{print $1}'| awk -F. '{print $1}' | awk '{ gsub(/Se/,""); print "show aps controller sonET "$1 }' > $3
      return 0
    ;;
    "analyze_resp" )
      # check $aps_output file exist or not
#      [ -e $2 ] ||  (RETVAL=$?; echo "file $2 not present exit.. $RETVAL "; exit $RETVAL) || exit $?
      [ -e $2 ]; check_exit_status "file $2 not present"
      # check "APS Group" keyword in file $aps_output
#debug      echo "APS ????"
        grep "APS Group" $2 > /dev/null || ( RETVAL=$?; echo "APS not configured on router exit.. $RETVAL "; rm $2;exit $RETVAL) || exit $RETVAL
      # check on "protect channel"keword in $aps_output
#debug      echo "protect ????"
#      grep "protect channel" $2 | awk '{print $1" " $2" "$6" " $7" on router, exit... 102"}'
      awk '/Inactive/ {print $1" " $2" "$6" " $7" on router, exit... 102"}' $2
      grep "Inactive" $2 > /dev/null && return 102
      echo " APS... OK"
      return 0
    ;;
   esac
  }
  
waite_function ()
# waite function and indication
  {
#    for i in `seq 1 $1` ; do
    for ((i = 0 ; i < $1 ; i++ )); do
#    for i in `eval echo {1..$1}` ; do
     echo -ne "$i \r"
#    echo -ne "$i \r"| dialog --gauge "Please wait" 10 70 0
    sleep 1
    done
  }
  
general_check ()
# genaral checking BTS and APS
# $1 - <hostname>
  {
    #-----------------------------------------------
#off 
send_command $1 $command_list_file  > $send_command_output_file || check_exit_status "ssh error" 
# check for exist requested BTS_name in $send_command_output_file
echo " check BTS on router"
#debug echo "debug-> $2"
#debug echo "debug-> $send_command_output_file"
grep "Mu" $send_command_output_file > /dev/null || check_exit_status "BTS not present on router"

# ----------- phase 1.2 ------ checking APS ----------------
# generate command list for check APS state
# !!! currently without exit analyze
#debug read
echo " check APS on router"
#debug echo " prep APS list"
generate_command_list_check_active_aps request_list $send_command_output_file $command_list_file
# 2-d connection
#off 
send_command $1 $command_list_file  > $aps_output || check_exit_status "ssh error" 
#debug echo " Analyze APS list"
generate_command_list_check_active_aps analyze_resp $aps_output 
#-------------------------------------------------
return $?
  }
  
search_host_name ()
# search server hostname in .db files
# set in global $hostname_1 - ASR hostname
# 
# $1 - <bts_name>
  {
#echo "debug> enter in  search_host_name" 
    grep -l $1 ./*.db > /dev/null || return 1
#echo "debug> checked hostname"    
    for i in `grep -l $1 ./*.db | sort`; do
#echo "debug> inside for loop"     
      hostname_1=`basename $i .db`
      generate_command_list_check $1 || check_exit_status "check list generation error" 
      # 1-st connection
      echo "`date +%Y-%m-%d_%H:%M:%S`"
      Mu_num=`grep $1 $i | awk '{ gsub(/Mu/,""); print $1 }'`
echo "debug>  Mu_num = $Mu_num"      
      # send 'sh int desc | i <BTS_Name> and  save output in $send_command_output_file
      general_check $hostname_1 && return 0
    done
  return 0    
  }  

ping_bts ()
# ping bts from router
# $1 ASR hostname
# $2 command to get info of Mu 
# $3 number of ping to send
  {
  # get IP address of BTS
  # tr at the end --- remove non-printable special characters/white space
    BTS_IP=$(echo "sh ppp multil int multil $2" | ssh -T $1 | awk '/Bundle name:/ {print $3}'| tr -dc '[:print:]')

echo "debug>  start ping BTS_IP= $BTS_IP"
    # check on null value
    if [[ -n "$BTS_IP" ]]
      then
	#echo "ping vrf Abis $BTS_IP rep $3 time 1" | ssh -T $1
	echo " $3 sec. silence to get proper output on sdtout........"
        ping_result=`(echo "ping vrf Abis $BTS_IP rep $3 time 1"; sleep $3 && sleep 3) | ssh -T $1 | grep Success`
        echo "`date +%Y-%m-%d_%H:%M:%S` --- $ping_result"
        echo "`date +%Y-%m-%d_%H:%M:%S` ping: $BTS_Name_glob $ping_result" >> `date +%Y-%m-%d`--bts_lock.log
	  else
	    echo "`date +%Y-%m-%d_%H:%M:%S` >>>>> BTS ================== $BTS_Name_glob ================== do not have IP"
	    echo "`date +%Y-%m-%d_%H:%M:%S` ping: >>>>> $BTS_Name_glob do not have IP" >> `date +%Y-%m-%d`--bts_lock.log
	    return 100
    fi
return 0
  }
  usage()
  # short help about options
  { 
    echo "Usage: $0 [-w <waite time>] [-m only Mu reset ]" 1>&2 
    exit 1 
   }
   getopts_fun ()
   {
echo "debug => enter in getopts_fun"
      while getopts "hw:m" options; do
      case "$options" in
        w)
            waite_time=${OPTARG}
            if [[ $waite_time =~ ^[0-9]+$ ]]
	      then 
		 echo " waite time = $waite_time"
		  else
		    echo -e " -w need integer argument \n exit...1"
		    exit 1
	     fi
            ;;
        p)
            p=${OPTARG}
            ;;
        h)
	    usage
	    ;;
        *)
            usage
            ;;
        :)
	    echo "Option -$OPTARG requires an argument." >&2
	    exit 1
	    ;;
    esac
done
shift $((OPTIND-1))
    }
# ----------------------------------------------- exe function -----------------------------

exe_function ()
  {

    # -------------------- exe function -------------------------------
    search_host_name $BTS_Name_glob || return 1
    echo "`date +%Y-%m-%d_%H:%M:%S`   --------- processing -----> $BTS_Name_glob ---------"
    # ---------------------------- action -----------------------------
    # ----------------- shutdown ----------------
    # generates command list 'shutdown' in $command_list_shut_file
    echo " shutdown phase"
    generate_command_list_shut_noShut shut || check_exit_status "list_shutown error"
    # 3-d connection
    # send commands from $command_list_shut_file
    #off
    send_command $hostname_1 $command_list_shut_file || check_exit_status "ssh error"

    # ----------- phase 3 ------ waiting ----------------
    # waiting 300 sec. before next actions
    echo "`date +%Y-%m-%d_%H:%M:%S`  === $BTS_Name_glob === waiting $waite_time sec. + 5 sec. on Mu.s + 20 sec. ping "
    #sleep $waite_time
    waite_function $waite_time

    # ----------- phase 4 ------ no shutdown ----------------
    # generate conmmands for 'no shutdown' in $command_list_shut_file
#    generate_command_list_shut_noShut noshut || check_exit_status "list_shutown error"
    #  generate conmmands for 'no shutdown' in $command_list_shut_file, only serials
    generate_command_list_shut_noShut noshut_ser || check_exit_status "list_shutown (Serial) error"
    # 4-th connection 
    # send commands from $command_list_shut_file
    #off
    send_command $hostname_1 $command_list_shut_file || check_exit_status "ssh error"
    # waiting 5 sec. before puting up 'Mu' on cisco
    echo "`date +%Y-%m-%d_%H:%M:%S`  === $BTS_Name_glob === waiting 5 sec. "
    #sleep $waite_time
    waite_function 5
    generate_command_list_shut_noShut noshut_mu || check_exit_status "list_shutown (Mu) error"
    # 5-th connection
    send_command $hostname_1 $command_list_shut_file || check_exit_status "ssh error"
    
    delete_tmp_files
    echo " waite before ping actions"
    waite_function 10
    ping_bts $hostname_1 $Mu_num 20
    
    # normal exit
    echo "`date +%Y-%m-%d_%H:%M:%S`   --------- end processing -----> $BTS_Name_glob --------- "
    return 0
    # -------------------- exe function -------------------------------
  }
#**************************************************
#    exe block
#**************************************************
 
# forward all parameters to getopts_fun
#getopts_fun $@

if [[ -n "$1" ]]
  then 
  echo "debug=> param#1 != 0"
  BTS_Name_glob=$1
  exe_function
    else
    
      while read BTS_Name_glob; do
      # pipeline to read <BTS_Name> from stdin
	if [[ -n "$BTS_Name_glob" ]]
	# check on null string
	  then
	    exe_function || echo " `date +%Y-%m-%d_%H:%M:%S` >>>>> BTS ================== $BTS_Name_glob ================== not found in .db exit.. 1"
	    
	  else
      echo "debug-> 0 string"
	fi
done
fi
echo "`date +%Y-%m-%d_%H:%M:%S` exit.. 0 "
exit 0
# ---------------------------- action end ---------------------------  
  
  
  